package which

import (
	"debug/elf"
	"debug/gosym"
	"errors"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
)

var filtered = map[string]struct{}{
	"/tmp/makerelease": {},
	"<autogenerated>":  {},
}

func init() {
	goroot := runtime.GOROOT()
	filtered[goroot] = struct{}{}
	if err := os.Setenv("GOROOT", ""); err == nil {
		filtered[runtime.GOROOT()] = struct{}{} // $GOROOT_FINAL
		os.Setenv("GOROOT", goroot)
	}
}

var (
	ErrNotFound  = errors.New("which: executable not found in $PATH")
	ErrNotGoExec = errors.New("which: not a Go executable")
	ErrGuessFail = errors.New("which: unable to guess an import path of main package")
)

// LookPath reads the import name of main package of the Go program by its name;
// the program is looked up in $PATH.
func LookPath(name string) (path, importpath string, err error) {
	if path, err = exec.LookPath(name); err != nil {
		return
	}
	importpath, err = Look(path)
	return
}

// Look reads the import name of main package of the Go executable under
// the given path.
func Look(path string) (importpath string, err error) {
	f, err := elf.Open(path)
	if err != nil {
		return "", ErrNotGoExec
	}
	defer f.Close()
	sym := f.Section(".gosymtab")
	if sym == nil {
		return "", ErrNotGoExec
	}
	symdat, err := sym.Data()
	if err != nil {
		return "", ErrNotGoExec
	}
	pcln := f.Section(".gopclntab")
	if pcln == nil {
		return "", ErrNotGoExec
	}
	pclndat, err := pcln.Data()
	if err != nil {
		return "", ErrNotGoExec
	}
	text := f.Section(".text")
	if text == nil {
		return "", ErrNotGoExec
	}
	lntab := gosym.NewLineTable(pclndat, text.Addr)
	if lntab == nil {
		return "", ErrNotGoExec
	}
	tab, err := gosym.NewTable(symdat, lntab)
	if err != nil {
		return "", ErrNotGoExec
	}
	var dirs = make(map[string]struct{})
	for file, obj := range tab.Files {
		for i := range obj.Funcs {
			// main.main symbol is referenced by every file of each package
			// imported by the main package of the executable.
			if obj.Funcs[i].Sym.Name == "main.main" && !isfiltered(file) {
				dirs[filepath.Dir(file)] = struct{}{}
			}
		}
	}
	if pkg, unique := guesspkg(filepath.Base(path), dirs); unique && pkg != "" {
		return pkg, err
	}
	return "", ErrGuessFail
}

func isfiltered(file string) bool {
	for f := range filtered {
		if strings.Contains(file, f) {
			return true
		}
	}
	return false
}

func guesspkg(name string, dirs map[string]struct{}) (pkg string, unique bool) {
	for _, s := range []string{"cmd/" + name, name} {
		for dir, _ := range dirs {
			if strings.Contains(dir, s) {
				if i := strings.LastIndex(dir, "/src/"); i != -1 {
					pkg = dir[i+len("/src/"):]
					if unique {
						unique = false
						return
					}
					unique = true
				}
			}
		}
		if unique {
			return
		}
	}
	return
}
