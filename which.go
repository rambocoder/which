package which

import (
	"debug/elf"
	"debug/gosym"
	"errors"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
)

type Program struct {
	Path    string
	Package string
}

var errNotFound = errors.New("which: executable not found in $PATH")
var errNotGoExec = errors.New("which: not a Go executable")
var errGuessFail = errors.New("which: unable to guess an import path of main package")

func LookPath(name string) (*Program, error) {
	path, err := exec.LookPath(name)
	if err != nil {
		return nil, errNotFound
	}
	return Look(path)
}

func Look(path string) (*Program, error) {
	f, err := elf.Open(path)
	if err != nil {
		return nil, errNotGoExec
	}
	defer f.Close()
	sym := f.Section(".gosymtab")
	if sym == nil {
		return nil, errNotGoExec
	}
	symdat, err := sym.Data()
	if err != nil {
		return nil, errNotGoExec
	}
	pcln := f.Section(".gopclntab")
	if pcln == nil {
		return nil, errNotGoExec
	}
	pclndat, err := pcln.Data()
	if err != nil {
		return nil, errNotGoExec
	}
	text := f.Section(".text")
	if text == nil {
		return nil, errNotGoExec
	}
	lntab := gosym.NewLineTable(pclndat, text.Addr)
	if lntab == nil {
		return nil, errNotGoExec
	}
	tab, err := gosym.NewTable(symdat, lntab)
	if err != nil {
		return nil, errNotGoExec
	}
	var dirs = make(map[string]struct{})
	for file, obj := range tab.Files {
		for i := range obj.Funcs {
			// main.main symbol is referenced by every file of each package
			// imported by the main package of the executable.
			if obj.Funcs[i].Sym.Name == "main.main" && !isfiltered(file) {
				dirs[filepath.Dir(file)] = struct{}{}
			}
		}
	}
	if pkg, unique := guesspkg(filepath.Base(path), dirs); unique && pkg != "" {
		return &Program{Path: path, Package: pkg}, nil
	}
	return nil, errGuessFail
}

var filtered = map[string]struct{}{
	"/tmp/makerelease": {},
	"<autogenerated>":  {},
}

func init() {
	goroot := runtime.GOROOT()
	filtered[goroot] = struct{}{}
	if err := os.Setenv("GOROOT", ""); err == nil {
		filtered[runtime.GOROOT()] = struct{}{} // $GOROOT_FINAL
		os.Setenv("GOROOT", goroot)
	}
}

func isfiltered(file string) bool {
	for f := range filtered {
		if strings.Contains(file, f) {
			return true
		}
	}
	return false
}

func guesspkg(name string, dirs map[string]struct{}) (pkg string, unique bool) {
	for _, s := range []string{"cmd/" + name, name} {
		for dir, _ := range dirs {
			if strings.Contains(dir, s) {
				if i := strings.LastIndex(dir, "/src/"); i != -1 {
					pkg = dir[i+len("/src/"):]
					if unique {
						unique = false
						return
					}
					unique = true
				}
			}
		}
		if unique {
			return
		}
	}
	return
}
