package which

import (
	"debug/gosym"
	"errors"
	"os"
	"path/filepath"
	"runtime"
	"strings"
)

// TODO(rjeczalik): support rest platform types

func init() {
	// Add $GOROOT and $GOROOT_FINAL to the filtered paths.
	goroot := runtime.GOROOT()
	filtered[goroot] = struct{}{}
	if err := os.Setenv("GOROOT", ""); err == nil {
		filtered[runtime.GOROOT()] = struct{}{} // $GOROOT_FINAL
		os.Setenv("GOROOT", goroot)
	}
	newfiles = append(newfiles, newelf)
}

type section interface {
	addr() uint64
	data() ([]byte, error)
}

type file interface {
	clos()
	section(string) section
	typ() *PlatformType
}

// All supported executable parsers.
var newfiles []func(string) (file, error)

// A path is discarded if it contains any of the filtered strings.
// Speeds up guesspkg.
var filtered = map[string]struct{}{
	"/tmp/makerelease": {},
	"<autogenerated>":  {},
}

var (
	// ErrNotGoExec is an error.
	ErrNotGoExec = errors.New("which: not a Go executable")
	// ErrGuessFail is an error.
	ErrGuessFail = errors.New("which: unable to guess an import path of the main package")
)

// PlatformType represents the target platform of the executable.
type PlatformType struct {
	GOOS   string // target operating system
	GOARCH string // target architecture
}

// String gives Go platform string.
func (etyp PlatformType) String() string {
	return etyp.GOOS + "_" + etyp.GOARCH
}

var (
	// PlatformDarwin386 represents the darwin_386 target arch.
	PlatformDarwin386 = &PlatformType{"darwin", "386"}
	// PlatformDarwinAMD64 represents the darwin_amd64 target arch.
	PlatformDarwinAMD64 = &PlatformType{"darwin", "amd64"}
	// PlatformFreeBSD386 represents the freebsd_386 target arch.
	PlatformFreeBSD386 = &PlatformType{"freebsd", "386"}
	// PlatformFreeBSDAMD64 represents the freebsd_amd64 target arch.
	PlatformFreeBSDAMD64 = &PlatformType{"freebsd", "amd64"}
	// PlatformLinux386 represents the linux_386 target arch.
	PlatformLinux386 = &PlatformType{"linux", "386"}
	// PlatformLinuxAMD64 represents the linux_amd64 target arch.
	PlatformLinuxAMD64 = &PlatformType{"linux", "amd64"}
	// PlatformWindows386 represents the windows_386 target arch.
	PlatformWindows386 = &PlatformType{"windows", "386"}
	// PlatformWindowsAMD64 represents the windows_amd64 target arch.
	PlatformWindowsAMD64 = &PlatformType{"windows", "amd64"}
)

// Exec represents a single Go executable file.
type Exec struct {
	Path  string        // Path to the executable.
	Type  *PlatformType // Fileutable file format.
	table *gosym.Table
}

// NewExec tries to detect executable etype for the given path and returns
// a new executable. It fails if file does not exist, is not a Go executable or
// it's unable to parse the file format.
func NewExec(path string) (*Exec, error) {
	etyp, symtab, pclntab, text, err := dumbnew(path)
	if err != nil {
		return nil, err
	}
	lntab := gosym.NewLineTable(pclntab, text)
	if lntab == nil {
		return nil, ErrNotGoExec
	}
	tab, err := gosym.NewTable(symtab, lntab)
	if err != nil {
		return nil, ErrNotGoExec
	}
	return &Exec{Path: path, Type: etyp, table: tab}, nil
}

// Import gives the import path of main package of given executable. It returns
// non-nil error when it fails to guess the exact path.
func (ex *Exec) Import() (string, error) {
	var dirs = make(map[string]struct{})
	for file, obj := range ex.table.Files {
		for i := range obj.Funcs {
			// main.main symbol is referenced by every file of each package
			// imported by the main package of the executable.
			if obj.Funcs[i].Sym.Name == "main.main" && !isfiltered(file) {
				dirs[filepath.Dir(file)] = struct{}{}
			}
		}
	}
	if pkg, unique := guesspkg(filepath.Base(ex.Path), dirs); unique && pkg != "" {
		return pkg, nil
	}
	return "", ErrGuessFail
}

// Import reads the import path of main package of the Go executable from
// the given path.
func Import(file string) (string, error) {
	ex, err := NewExec(file)
	if err != nil {
		return "", err
	}
	return ex.Import()
}

func dumbnew(path string) (etyp *PlatformType, symtab, pclntab []byte, text uint64, err error) {
	var f file
	for _, newf := range newfiles {
		if f, err = newf(path); err != nil {
			continue
		}
		if symtab, pclntab, text, err = newfile(path, f); err == nil {
			etyp = f.typ()
			f.clos()
			return
		}
		f.clos()
	}
	return
}

func newfile(path string, f file) (symtab, pclntab []byte, text uint64, err error) {
	sym := f.section(".gosymtab")
	if sym == nil {
		err = ErrNotGoExec
		return
	}
	symtab, err = sym.data()
	if err != nil {
		err = ErrNotGoExec
		return
	}
	pcln := f.section(".gopclntab")
	if pcln == nil {
		err = ErrNotGoExec
		return
	}
	pclntab, err = pcln.data()
	if err != nil {
		err = ErrNotGoExec
		return
	}
	txt := f.section(".text")
	if txt == nil {
		err = ErrNotGoExec
		return
	}
	text = txt.addr()
	return
}

func isfiltered(file string) bool {
	for f := range filtered {
		if strings.Contains(file, f) {
			return true
		}
	}
	return false
}

func guesspkg(name string, dirs map[string]struct{}) (pkg string, unique bool) {
	for _, s := range []string{"cmd/" + name, name} {
		for dir := range dirs {
			if strings.Contains(dir, s) {
				if i := strings.LastIndex(dir, "/src/"); i != -1 {
					pkg = dir[i+len("/src/"):]
					if unique {
						unique = false
						return
					}
					unique = true
				}
			}
		}
		if unique {
			return
		}
	}
	return
}
